#include <algorithm>
#include <cstdint>
#include <iostream>
#include <random>
#include <tuple>
#include <vector>

#include <sventt/sventt.hpp>

#include <boost/multiprecision/cpp_int.hpp>

#include <gtest/gtest.h>

#include "gaussian-polynomial.hpp"
#include "restricted-partition.hpp"

template <typename modulus_type> class ModulusFixture : public testing::Test {};

using ModulusTypes = ::testing::Types<
    /* A famous Goldilocks prime with the smallest generator. */
    sventt::Modulus<UINT64_C(0xffff'ffff'0000'0001), 7>,
    /* A famous Goldiloks prime with a random generator. */
    sventt::Modulus<UINT64_C(0xffff'ffff'0000'0001),
                    UINT64_C(0xf448'72f5'ec1c'4cc0)>,
    /* A random 64-bit prime. */
    sventt::Modulus<UINT64_C(0xa3b2'5f40'0c7a'8001), 5>,
    /* A random 63-bit prime. */
    sventt::Modulus<UINT64_C(0x41d3'3d0d'1fbf'8001), 6>>;

TYPED_TEST_SUITE(ModulusFixture, ModulusTypes);

TYPED_TEST(ModulusFixture, QPochhammer) {
  using modulus_type = TypeParam;

  /* Tuples of k and coefficients in qpoch(q, q, k), generated by:
   * CoefficientList[QPochhammer[q, q, k] // FunctionExpand, q]
   */
  const std::vector<std::tuple<std::uint64_t, std::vector<int>>> expected{
      {7, {1, -1, -1, 0, 0, 1,  0,  1, 1,  0, -1, -1, -2, 0, 0,
           0, 2,  1,  1, 0, -1, -1, 0, -1, 0, 0,  1,  1,  -1}},
      {8, {1, -1, -1, 0, 0,  1,  0,  1, 0, 1, 0, -1, -2, -1, 0, -1, 1,  1, 2,
           1, 1,  -1, 0, -1, -2, -1, 0, 1, 0, 1, 0,  1,  0,  0, -1, -1, 1}},
      {10,
       {1, -1, -1, 0,  0,  1,  0,  1,  0,  0,  0,  1,  -1, -1, -1, -2, 0,  0, 1,
        1, 1,  1,  3,  0,  0,  -1, -1, -2, -2, -1, -1, 0,  0,  3,  1,  1,  1, 1,
        0, 0,  -2, -1, -1, -1, 1,  0,  0,  0,  1,  0,  1,  0,  0,  -1, -1, 1}},
      {21,
       {1,  -1, -1, 0,  0,  1,  0,  1,  0,  0,  0,  0,  -1, 0,  0,  -1, 0,  0,
        0,  0,  0,  0,  2,  0,  -1, -1, 0,  0,  0,  1,  1,  1,  1,  1,  0,  -1,
        0,  -1, -1, -1, -2, -1, -1, -1, 1,  0,  0,  -1, 0,  0,  0,  2,  1,  2,
        2,  3,  2,  3,  1,  1,  0,  0,  -2, -2, -3, -3, -2, -3, -3, -3, -4, -3,
        -2, -1, 0,  1,  2,  2,  4,  5,  6,  5,  6,  5,  4,  3,  2,  0,  1,  -2,
        -3, -4, -4, -8, -7, -7, -7, -6, -5, -5, -2, -1, 0,  3,  4,  6,  6,  8,
        7,  8,  8,  7,  5,  5,  3,  2,  -2, -3, -5, -5, -7, -8, -8, -7, -8, -6,
        -6, -4, -3, 0,  1,  2,  5,  5,  6,  7,  7,  7,  8,  4,  4,  3,  2,  -1,
        0,  -2, -3, -4, -5, -6, -5, -6, -5, -4, -2, -2, -1, 0,  1,  2,  3,  4,
        3,  3,  3,  2,  3,  3,  2,  2,  0,  0,  -1, -1, -3, -2, -3, -2, -2, -1,
        -2, 0,  0,  0,  1,  0,  0,  -1, 1,  1,  1,  2,  1,  1,  1,  0,  1,  0,
        -1, -1, -1, -1, -1, 0,  0,  0,  1,  1,  0,  -2, 0,  0,  0,  0,  0,  0,
        1,  0,  0,  1,  0,  0,  0,  0,  -1, 0,  -1, 0,  0,  1,  1,  -1}},
  };

  std::default_random_engine generator{42};
  std::uniform_int_distribution<std::uint64_t> distribution;

  for (const auto &[k, correct_coefficients] : expected) {
    std::vector<std::uint64_t> coefficients(k * (k + 1) / 2 + 1);
    std::ranges::generate(coefficients,
                          [&] { return distribution(generator); });
    calculate_q_pochhammer<modulus_type>(coefficients, k);

    EXPECT_EQ(coefficients.size(), correct_coefficients.size()) << "k = " << k;

    for (std::uint64_t i = 0;
         i < std::min(coefficients.size(), correct_coefficients.size()); ++i) {
      EXPECT_EQ(coefficients.at(i),
                correct_coefficients.at(i) >= 0
                    ? correct_coefficients.at(i)
                    : correct_coefficients.at(i) + modulus_type::get_modulus())
          << "k = " << k << ", i = " << i;
    }
  }
}

TYPED_TEST(ModulusFixture, RestrictedPartition) {
  using modulus_type = TypeParam;

  /*
   * Tuples of k and list of p(0, k), p(1, k), ..., p(n, k), generated by:
   * Table[IntegerPartitions[i, k] // Length, {i, 0, n}]
   */
  const std::vector<std::tuple<std::uint64_t, std::vector<int>>> expected{
      {7,
       {1,      1,      2,      3,      5,      7,      11,     15,     21,
        28,     38,     49,     65,     82,     105,    131,    164,    201,
        248,    300,    364,    436,    522,    618,    733,    860,    1009,
        1175,   1367,   1579,   1824,   2093,   2400,   2738,   3120,   3539,
        4011,   4526,   5102,   5731,   6430,   7190,   8033,   8946,   9953,
        11044,  12241,  13534,  14950,  16475,  18138,  19928,  21873,  23961,
        26226,  28652,  31275,  34082,  37108,  40340,  43819,  47527,  51508,
        55748,  60289,  65117,  70281,  75762,  81612,  87816,  94425,  101423,
        108869, 116742, 125104, 133939, 143307, 153192, 163662, 174696, 186366,
        198655, 211634, 225286, 239691, 254826, 270775, 287521, 305146, 323633,
        343074, 363446, 384845, 407254, 430768, 455370, 481165, 508130, 536375,
        565883, 596763, 628998, 662708, 697870, 734609, 772909, 812893}},
      {42, {1,     1,     2,     3,     5,     7,     11,    15,    22,
            30,    42,    56,    77,    101,   135,   176,   231,   297,
            385,   490,   627,   792,   1002,  1255,  1575,  1958,  2436,
            3010,  3718,  4565,  5604,  6842,  8349,  10143, 12310, 14883,
            17977, 21637, 26015, 31185, 37338, 44583, 53174, 63260, 75173}},
      {1234,
       {1,       1,       2,       3,       5,       7,       11,      15,
        22,      30,      42,      56,      77,      101,     135,     176,
        231,     297,     385,     490,     627,     792,     1002,    1255,
        1575,    1958,    2436,    3010,    3718,    4565,    5604,    6842,
        8349,    10143,   12310,   14883,   17977,   21637,   26015,   31185,
        37338,   44583,   53174,   63261,   75175,   89134,   105558,  124754,
        147273,  173525,  204226,  239943,  281589,  329931,  386155,  451276,
        526823,  614154,  715220,  831820,  966467,  1121505, 1300156, 1505499,
        1741630, 2012558, 2323520, 2679689, 3087735, 3554345}},
  };

  for (const auto &[k, pnk_list] : expected) {
    RestrictedPartition<modulus_type> restricted_partition(k);

    for (const int pnk : pnk_list) {
      EXPECT_EQ(restricted_partition(), modulus_type::reduce(pnk))
          << "k = " << k << ", n = " << restricted_partition.get_n();
      restricted_partition.advance();
    }
  }
}

TYPED_TEST(ModulusFixture, GaussianPolynomialNumeratorSegment) {
  using modulus_type = TypeParam;

  /*
   * Tuples of k and coefficients in qbinom(k, l, q) for l = 0, 1, ..., k,
   * generated by:
   * Table[CoefficientList[QBinomial[k, l, q] // FunctionExpand, q], {l, 0, k}]
   */
  const std::vector<std::tuple<std::uint64_t, std::vector<std::vector<int>>>>
      expected{
          {8,
           {{1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 2, 2, 3, 3, 4, 3, 3, 2, 2, 1, 1},
            {1, 1, 2, 3, 4, 5, 6, 6, 6, 6, 5, 4, 3, 2, 1, 1},
            {1, 1, 2, 3, 5, 5, 7, 7, 8, 7, 7, 5, 5, 3, 2, 1, 1},
            {1, 1, 2, 3, 4, 5, 6, 6, 6, 6, 5, 4, 3, 2, 1, 1},
            {1, 1, 2, 2, 3, 3, 4, 3, 3, 2, 2, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1}}},
          {9,
           {{1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 2, 2, 3, 3, 4, 4, 4, 3, 3, 2, 2, 1, 1},
            {1, 1, 2, 3, 4, 5, 7, 7, 8, 8, 8, 7, 7, 5, 4, 3, 2, 1, 1},
            {1,  1,  2, 3, 5, 6, 8, 9, 11, 11, 12,
             11, 11, 9, 8, 6, 5, 3, 2, 1,  1},
            {1,  1,  2, 3, 5, 6, 8, 9, 11, 11, 12,
             11, 11, 9, 8, 6, 5, 3, 2, 1,  1},
            {1, 1, 2, 3, 4, 5, 7, 7, 8, 8, 8, 7, 7, 5, 4, 3, 2, 1, 1},
            {1, 1, 2, 2, 3, 3, 4, 4, 4, 3, 3, 2, 2, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1}}},
          {10,
           {{1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 2, 2, 3, 3, 4, 4, 5, 4, 4, 3, 3, 2, 2, 1, 1},
            {1,  1,  2, 3, 4, 5, 7, 8, 9, 10, 10,
             10, 10, 9, 8, 7, 5, 4, 3, 2, 1,  1},
            {1,  1,  2,  3,  5,  6, 9, 10, 13, 14, 16, 16, 18,
             16, 16, 14, 13, 10, 9, 6, 5,  3,  2,  1,  1},
            {1,  1,  2,  3,  5,  7,  9, 11, 14, 16, 18, 19, 20,
             20, 19, 18, 16, 14, 11, 9, 7,  5,  3,  2,  1,  1},
            {1,  1,  2,  3,  5,  6, 9, 10, 13, 14, 16, 16, 18,
             16, 16, 14, 13, 10, 9, 6, 5,  3,  2,  1,  1},
            {1,  1,  2, 3, 4, 5, 7, 8, 9, 10, 10,
             10, 10, 9, 8, 7, 5, 4, 3, 2, 1,  1},
            {1, 1, 2, 2, 3, 3, 4, 4, 5, 4, 4, 3, 3, 2, 2, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1}}},
      };

  for (const auto &[k, correct_coefficients_list] : expected) {
    GaussianPolynomialNumeratorSegment<modulus_type> segment(k);

    for (const std::vector<int> &correct_coefficients :
         correct_coefficients_list) {
      segment.advance();
      const std::vector<std::uint64_t> &coefficients{
          segment.get_coefficients()};

      EXPECT_EQ(coefficients.size(), correct_coefficients.size())
          << "k = " << k;

      for (std::size_t i = 0;
           i < std::min(coefficients.size(), correct_coefficients.size());
           ++i) {
        EXPECT_EQ(coefficients[i], correct_coefficients[i])
            << "k = " << k << ", j = " << segment.get_j() << ", i = " << i;
      }
    }

    EXPECT_EQ(segment.get_j(), k) << "k = " << k;
  }
}

TYPED_TEST(ModulusFixture, GaussianPolynomialNumerator) {
  using modulus_type = TypeParam;

  /*
   * Tuples of n, k, and coefficients in the numerator of qbinom(n, k, q),
   * generated by:
   * CoefficientList[Product[1 - q^(n - j + 1), {j, k}], q]
   */
  const std::vector<std::tuple<std::uint64_t, std::uint64_t, std::vector<int>>>
      expected{
          {4, 2, {1, 0, 0, -1, -1, 0, 0, 1}},
          {25, 5, {1,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0,  0,
                   0,  0,  0,  0,  -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0,  0,
                   0,  0,  0,  0,  0,  0,  0,  0,  0,  1, 1, 2, 2, 2, 1, 1,  0,
                   0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, -1, -1,
                   -2, -2, -2, -1, -1, 0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0,  0,
                   0,  0,  0,  0,  0,  1,  1,  1,  1,  1, 0, 0, 0, 0, 0, 0,  0,
                   0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0, -1}},
          {64,
           8,
           {1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, 0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  2,
            3,  3,  4,  3,  3,  2,  2,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  -1, -1, -2, -3, -4, -5, -6, -6, -6, -6, -5, -4, -3,
            -2, -1, -1, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  3,
            5,  5,  7,  7,  8,  7,  7,  5,  5,  3,  2,  1,  1,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  -1, -1, -2, -3, -4, -5, -6, -6, -6, -6, -5,
            -4, -3, -2, -1, -1, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            1,  1,  2,  2,  3,  3,  4,  3,  3,  2,  2,  1,  1,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  -1, -1, -1, -1, -1,
            -1, -1, -1, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  1}},
      };

  for (const auto &[n, k, correct_coefficients] : expected) {
    for (std::uint64_t size{1}; size <= correct_coefficients.size(); ++size) {
      GaussianPolynomialNumerator<modulus_type> numerator(n, k);

      for (std::uint64_t i{}; i < correct_coefficients.size() * 42; i += size) {
        std::vector<std::uint64_t> coefficients(size);
        std::iota(coefficients.begin(), coefficients.end(), 0);
        numerator.subtract_next(coefficients.data(), size);

        for (std::uint64_t j{}; j < size; ++j) {
          EXPECT_EQ(coefficients.at(j),
                    i + j < correct_coefficients.size()
                        ? (correct_coefficients.at(i + j) >= 0
                               ? modulus_type::subtract(
                                     j, correct_coefficients.at(i + j))
                               : modulus_type::add(
                                     j, modulus_type::get_modulus() -
                                            correct_coefficients.at(i + j)))
                        : j)
              << "size = " << size << ", n = " << n << ", k = " << k
              << ", pos = " << i + j << " (i = " << i << ", j = " << j << ") / "
              << correct_coefficients.size();
        }
      }
    }
  }
}

TYPED_TEST(ModulusFixture, GaussianPolynomialCoefficient) {
  using modulus_type = TypeParam;
  using modmul_type = sventt::PAdic64SVE<modulus_type>;

  constexpr std::uint64_t len{std::uint64_t{1} << 15};
  using kernel_type = sventt::IterativeNTT<
      modulus_type, len,
      sventt::RadixEightSVELayer<modmul_type, len, std::uint64_t{1} << 15>,
      sventt::RadixEightSVELayer<modmul_type, len, std::uint64_t{1} << 12>,
      sventt::RadixEightSVELayer<modmul_type, len, std::uint64_t{1} << 9>,
      sventt::RadixEightSVELayer<modmul_type, len, std::uint64_t{1} << 6>,
      sventt::RadixEightSVELayer<modmul_type, len, std::uint64_t{1} << 3, len>>;

  sventt::NTT<kernel_type> ntt{true, true, false};

  const std::vector<std::tuple<std::uint64_t, std::string>> expected{
      {10, "78132541528"},
      {25, "140170526450793924490478768121814869629364"},
      {35, "13872534241478210358349096341203128450357241660871429860873721318"},
      {42, "1195452957914568544628242649935060977711193839443701120065551521757"
           "686130217168310"},
      {100, "904300736808894426574793302240693911261234942398748154528052171724"
            "305279045583459861011357813556260746366850646669062169890178280824"
            "885995375485156399921958991796250954308603011799192842071430359668"
            "946052264146938445899732873114858199920"},
  };

  for (const auto &[m, expected_count_string] : expected) {
    const std::uint64_t count{calculate_number_of_magic_series(m, ntt)};
    const std::uint64_t expected_count{
        boost::multiprecision::cpp_int(expected_count_string) %
        modulus_type::get_modulus()};
    EXPECT_EQ(count, expected_count) << "m = " << m;
  }
}
